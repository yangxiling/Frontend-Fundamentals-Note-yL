:question: 1.如何通过 一个 不均匀的硬币得到公平的结果？

&emsp;:pencil2: A：抛出一次硬币正面朝上的概率是p，反面朝上的概率是(p-1);

|      |     0     |        1        |
| :--: | :-------: | :-------------: |
|  0   |     p     |    p*（p-1）    |
|  1   | （p-1）*p | （p-1）*（p-1） |

根据表格可以看出：（0，1）和（1，0）两种情况的概率是相同的。所以连续抛两次硬币，如果得到相同的结果就重新抛两次。出现 “正 反” 或 “反 正”情况就获得两个相等概率的事件，结果就是公平的。

:question:1.1 给定一个 foo 函数，60%的概率返回0，40%的概率返回1，如何利用 foo 函数实现一个 50% 返回 0 的函数？

&emsp;:pencil2: A:获得（1，0）和（0，1）的概率是一样的，就可构造出50%概率，所以出现这两种情况就返回。出现（0，0）和（1，1）结果就抛弃重新开始。

```javascript
function half01(){
  while(true){
     let a = foo();
 		 let b = foo();
    if(a!=b) return a&b;
   }
}
```

:question:2.有序链表插入的时间复杂度是多少？

&emsp; :pencil2: A：因为是有序链表，需要迭代找到合适的位置，所以插入的时间复杂度是O(n)

:question:3.常用的排序方式有哪些，时间复杂度是多少？

&emsp;:pencil2: A:[冒泡](./src/bubbleSort.js)、[选择](./src/selectionSort.js)、[插入](./src/insertSort.js)的时间复杂度都是O(n²)；[归并](./src/mergeSort.js)、[希尔](./src/shellSort.js)、[快速](./src/quickSort.js)的时间复杂度是O(nlogn)

:question:4.使用递归及非递归两种方式实现快速排序

&emsp; :pencil2: A：[快速排序的两种方法](./src/quickSort.js)

:question:4. 快速排序的空间复杂度是多少？时间复杂度的最好最坏的情况是多少，有哪些优化方案？

&emsp;:pencil2: A: 空间复杂度：平均情况O(logn)。空间复杂度主要是递归造成的栈空间的使用。

快速排序的时间复杂度O(nlogn)。最好的情况递归树的深度是O(log2n),即元素均匀分为两个子序列，时间复杂度O(nlogn)；最坏情况元素都分到一个子序列，另一个序列为空，时间复杂度O(n²)。

**优化方案：主要从&emsp;pivot的选取、处理重复元素的问题、优化小数组的效率&emsp;这几个方面考虑**

1.合理pivot的选取:直接选择分区的第一项或者是最后一项是很不合理的。对于已经排好序或者接近排好序的数组会直接进入最差的情况，时间复杂度O(n²)

**1.pivot选取理想的情况是：**让分区中比pivot小的元素数量和比pivot大的元素数量差不多。较常用的做法是三数取中，  即从第一项、最后一项和中间项 取中位数作为pivot。当然这并不能完全避免最差的情况发生，所以很多时候会采取更小心、更严谨的pivot选择方案（对于大数组特别重要）。比如把数组分成三段，每段用三数取中找出中位数，再从得到的中位数中找出中位数。

如果是数量级很大的数组，可以每隔200左右（不固定）选取一个元素，找出其中的中位数，再加入首位两个元素，从这三个元素中找出中位数。（javascript v8引擎中的一个选取pivot方法）

**2.处理重复元素的问题：**如果一个大数组中重复元素很多，也会使快排进入最差的情况。可以创建一个数组pivotSame专门存放与pivot相同的元素，最后拼接left、pivotSame和rigth。

**3.优化小数组的效率：**对于数组的规模很小快排可能并没有优势，所以可以用插入排序替代。

（还有方案：递归优化-->尾递归。javascript没有，但是可以用循环变相手动实现尾递归优化同样的效果[v8 案例]）

